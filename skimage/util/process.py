__all__ = ['process_blocks', 'FuncExec']

import numpy as np
from skimage.util import view_as_windows
from multiprocessing import Pool
from Queue import Queue

class FuncExec(object):
    """FuncExec is a function execution helper class.
    It is a base class that allows for synchronous execution of a function
    that operates on views of an input array that was typically
    passed to the view_as_windows or view_as_blocks functions.
    """
    def __init__(self, func, func_args={}, callback=None):
        self.func = func
        self.func_args = func_args
        self.cb_done = callback
        self.queue = None
        self.num_busy = None
        self.num_ready = None
        self.out_shape = None
        self.views = None

    def __call__(self, views, dims=None):
        if dims is None:
            dims = len(views.shape)/2
        elif dims > len(views.shape):
            raise ValueError("Parameter 'dims' must not be larger than\
                    the number of dimensions of the 'views' parameter.")
        self.views = views
        self.num_busy = 0
        self.num_ready = 0
        self.queue = Queue()
        self.out_shape = self.views.shape[:dims]
        self._map(np.ndindex(*self.out_shape), )
        return self

    def _callback(self, index, result):
        self.queue.put((index,result))
        self.num_busy -= 1
        self.num_ready += 1
        if self.cb_done is not None:
            if self.num_ready == np.prod(self.out_shape):
                self.cb_done(self)

    def _map(self, indices):
        index_arr = [index for index in indices]
        map(self._exec, [self.views[index] for index in index_arr], index_arr)

    def _exec(self, view, index):
        result = self.func(view, **self.func_args)
        self._callback(index, result)

    def ready(self, timeout=0):
        count = 0
        while count < np.prod(self.out_shape):
            idx, value = self.queue.get(True, timeout)
            if isinstance(value, np.ndarray):
                yield idx, value.astype(None)
            else:
                yield idx, value
            count += 1

    def result(self, timeout=0):
        result = np.zeros(self.out_shape).astype(np.object)
        for idx, value in self.ready(timeout):
            result[idx] = value
        return np.array(result.tolist())



def process_blocks(image, block_shape, func, func_args={},
                   overlap=0, n_jobs=1):
    """Apply a function to distinct or overlapping blocks in the image.

    Parameters
    ----------
    image : ndarray
        Input image.
    block_shape : tuple
        Block size.
    func : callable, f(
        Function to be applied to each window.
    func_args : dict
        Additional arguments for `func`.
    overlap : int
        The amount of overlap between blocks.
    jobs : int
        The number of jobs to launch in parallel.

    Returns
    -------
    output : ndarray
        Outputs generated by applying the function to each block.

    Examples
    --------
    >>> from skimage.data import camera
    >>> image = camera()
    >>> output = process_windows(image, (8, 8), np.sum)
    >>>
    >>> from skimage.color import gray2rgb
    >>> output2 = process_windows(gray2rgb(image), (8, 8, 3),
    ...                           np.sum, {'axis': -1})

    """
    block_shape = np.asarray(block_shape)
    step = max(block_shape) - overlap

    if block_shape.size != image.ndim:
        raise ValueError("Block shape must correspond to image dimensions")

    image_views = view_as_windows(image, block_shape, step)
    out_shape = image_views.shape[:-block_shape.size]
    indicies = np.ndindex(*out_shape)

    if n_jobs > 1:
        func_map = partial(func, **func_args)
        pool = Pool(processes=n_jobs)
        output = np.array(pool.map(func_map,
                                   [image_views[idx] for idx in indicies]))
    else:
        output = np.array([func(image_views[idx], **func_args)
                           for idx in indicies])

    return output.reshape(out_shape + output.shape[1:])

